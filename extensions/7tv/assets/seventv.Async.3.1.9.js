var c=Object.defineProperty;var h=(t,s,e)=>s in t?c(t,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[s]=e;var i=(t,s,e)=>(h(t,typeof s!="symbol"?s+"":s,e),e);class v{constructor(){i(this,"isResolved",!1);i(this,"resolve");i(this,"reject");i(this,"then");i(this,"catch");i(this,"finally");const s=new Promise((e,r)=>{this.resolve=e,this.reject=r});this.then=(...e)=>s.then(...e),this.catch=(...e)=>s.catch(...e),this.finally=(...e)=>s.finally(...e)}emit(s){var e;this.isResolved=!0,(e=this.resolve)==null||e.call(this,s),this.resolve=void 0,this.reject=void 0}}class u extends v{constructor(e,r,o){super();i(this,"observer");this.observer=new MutationObserver(n=>{e(n,this.emit.bind(this))}),this.observer.observe(r,o)}emit(e){super.emit(e),this.disconnect()}disconnect(){var e,r;(e=this.observer)==null||e.disconnect(),this.observer=void 0,this.isResolved||(r=this.reject)==null||r.call(this,new d)}}class d extends Error{constructor(){super("ObserverPromise: Observer disconnected before resolving.")}}function a(t,s=100){let e;return(...r)=>{clearTimeout(e),e=window.setTimeout(()=>(e=void 0,t(...r)),s)}}export{u as O,a as d};
